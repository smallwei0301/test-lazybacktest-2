<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Worker.js å¯¦éš›ä»£ç¢¼è·¯å¾‘æ¸¬è©¦</title>
    <style>
        body {
            font-family: monospace;
            padding: 20px;
            background: #1e1e1e;
            color: #d4d4d4;
        }

        .log {
            margin: 10px 0;
            padding: 10px;
            background: #252526;
            border-left: 3px solid #007acc;
        }

        .success {
            border-left-color: #4ec9b0;
        }

        .error {
            border-left-color: #f48771;
        }

        .warn {
            border-left-color: #dcdcaa;
        }

        button {
            padding: 10px 20px;
            margin: 5px;
            background: #007acc;
            color: white;
            border: none;
            cursor: pointer;
        }

        button:hover {
            background: #005a9e;
        }

        pre {
            background: #2d2d2d;
            padding: 10px;
            overflow-x: auto;
        }
    </style>
</head>

<body>
    <h1>æ¸¬è©¦ Worker.js çš„å¯¦éš› idbSetPermanentInvalid å¯¦ç¾</h1>
    <p><strong>âš ï¸ æœ¬æ¸¬è©¦ç›´æ¥è¤‡è£½ä¸¦ä½¿ç”¨ worker.js ä¸­çš„å¯¦éš›ä»£ç¢¼</strong></p>

    <button onclick="testActualImplementation()">åŸ·è¡Œå¯¦éš›ä»£ç¢¼è·¯å¾‘æ¸¬è©¦</button>
    <button onclick="checkDatabase()">æª¢æŸ¥è³‡æ–™åº«å…§å®¹</button>
    <button onclick="clearDB()">æ¸…é™¤è³‡æ–™åº«</button>

    <div id="output"></div>

    <script>
        // ==================== ä»¥ä¸‹ä»£ç¢¼ç›´æ¥è¤‡è£½è‡ª worker.js ====================

        // Patch: LB-IDB-CACHE-PROPOSAL-v1 â€” IndexedDB Native Helper for Persistent Cache
        // Patch: LB-INVALID-DATA-FALLBACK-20251202E â€” IndexedDB é…ç½®å‡ç´š
        const IDB_CONFIG = {
            name: 'LazyBacktestDB',
            version: 4, // Patch: LB-INVALID-DATA-FALLBACK-20251202G - ä¿®æ­£ permanentInvalidDates keyPath
            storeName: 'stock_cache'
        };

        const PERMANENT_INVALID_STORE_NAME = 'permanentInvalidDates';
        const PERMANENT_INVALID_TTL_MS = 24 * 60 * 60 * 1000; // æ°¸ä¹…ç„¡æ•ˆè³‡æ–™ 24 å°æ™‚ TTL
        const IDB_ADJ_TTL_MS = 24 * 60 * 60 * 1000; // é‚„åŸè‚¡åƒ¹ 24 å°æ™‚ TTL
        let idbInstance = null;

        /**
         * åˆå§‹åŒ– IndexedDB é€£ç·š
         * @returns {Promise<IDBDatabase|null>}
         */
        function initIDB() {
            if (idbInstance) return Promise.resolve(idbInstance);

            return new Promise((resolve) => {
                try {
                    const request = indexedDB.open(IDB_CONFIG.name, IDB_CONFIG.version);

                    request.onerror = () => {
                        console.warn('[Worker IDB] ç„¡æ³•é–‹å•Ÿ IndexedDB:', request.error);
                        resolve(null);
                    };

                    request.onsuccess = () => {
                        idbInstance = request.result;
                        console.log('[Worker IDB] IndexedDB åˆå§‹åŒ–æˆåŠŸ');
                        resolve(idbInstance);
                    };

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;

                        // ä¸»å¿«å– store
                        if (!db.objectStoreNames.contains(IDB_CONFIG.storeName)) {
                            db.createObjectStore(IDB_CONFIG.storeName);
                            console.log('[Worker IDB] å»ºç«‹ ObjectStore:', IDB_CONFIG.storeName);
                        }

                        // Patch: LB-INVALID-DATA-FALLBACK-20251202G â€” æ°¸ä¹…ç„¡æ•ˆè³‡æ–™ store (å« keyPath ä¿®æ­£)
                        if (!db.objectStoreNames.contains(PERMANENT_INVALID_STORE_NAME)) {
                            const permanentStore = db.createObjectStore(PERMANENT_INVALID_STORE_NAME, { keyPath: 'id' });
                            permanentStore.createIndex('stockNo', 'stockNo', { unique: false });
                            permanentStore.createIndex('expiresAt', 'expiresAt', { unique: false });
                            console.log('[Worker IDB] å»ºç«‹ ObjectStore:', PERMANENT_INVALID_STORE_NAME);
                        }
                    };
                } catch (error) {
                    console.warn('[Worker IDB] IndexedDB åˆå§‹åŒ–å¤±æ•— (å¯èƒ½ç‚ºéš±ç§æ¨¡å¼):', error);
                    resolve(null);
                }
            });
        }

        /**
         * å°‡ç„¡æ•ˆæ—¥æœŸå¯«å…¥ IndexedDB
         * @param {string} stockNo è‚¡ç¥¨ä»£ç¢¼
         * @param {string} date ç„¡æ•ˆæ—¥æœŸ (YYYY-MM-DD)
         * @returns {Promise<void>}
         */
        async function idbSetPermanentInvalid(stockNo, date) {
            console.log(`[Worker IDB Debug] idbSetPermanentInvalid called for ${stockNo} ${date}`);
            try {
                const db = await initIDB();
                console.log(`[Worker IDB Debug] DB initialized: ${!!db}`);
                if (!db) {
                    console.warn('[Worker IDB] ç„¡æ³•å¯«å…¥æ°¸ä¹…ç„¡æ•ˆæ—¥æœŸï¼ŒDB æœªåˆå§‹åŒ–');
                    return;
                }

                const expiresAt = Date.now() + PERMANENT_INVALID_TTL_MS;
                const entry = {
                    id: `${stockNo}|${date}`,
                    stockNo,
                    date,
                    expiresAt,
                    recordedAt: Date.now()
                };

                return new Promise((resolve, reject) => {
                    console.log(`[Worker IDB Debug] Creating transaction for ${PERMANENT_INVALID_STORE_NAME}`);
                    try {
                        const transaction = db.transaction([PERMANENT_INVALID_STORE_NAME], 'readwrite');
                        const store = transaction.objectStore(PERMANENT_INVALID_STORE_NAME);
                        const request = store.put(entry); // âœ… ä¿®æ­£å¾Œï¼šåªå‚³ä¸€å€‹åƒæ•¸
                        console.log(`[Worker IDB Debug] Put request created`);

                        request.onsuccess = () => {
                            console.log(`[Worker IDB] å·²è¨˜éŒ„æ°¸ä¹…ç„¡æ•ˆæ—¥æœŸ: ${stockNo} - ${date}`);
                            resolve();
                        };

                        request.onerror = () => {
                            console.warn(`[Worker IDB] å¯«å…¥æ°¸ä¹…ç„¡æ•ˆæ—¥æœŸå¤±æ•—: ${stockNo} - ${date}`, request.error);
                            resolve();
                        };
                    } catch (txError) {
                        console.warn('[Worker IDB] idbSetPermanentInvalid äº¤æ˜“éŒ¯èª¤:', txError);
                        resolve();
                    }
                });
            } catch (e) {
                console.warn('[Worker IDB] idbSetPermanentInvalid éŒ¯èª¤:', e);
            }
        }

        // ==================== æ¸¬è©¦è¼”åŠ©å‡½æ•¸ ====================

        function log(message, type = 'log') {
            const output = document.getElementById('output');
            const div = document.createElement('div');
            div.className = `log ${type}`;
            div.textContent = `[${new Date().toISOString().substr(11, 8)}] ${message}`;
            output.appendChild(div);
            console.log(message);
        }

        async function testActualImplementation() {
            log('â”â”â” é–‹å§‹æ¸¬è©¦å¯¦éš› worker.js ä»£ç¢¼è·¯å¾‘ â”â”â”', 'log');

            // æ¸¬è©¦èˆ‡ worker.js å®Œå…¨ç›¸åŒçš„èª¿ç”¨æ–¹å¼
            const testCases = [
                { stockNo: '2317', date: '2025-07-30' },
                { stockNo: '2330', date: '2025-08-15' },
                { stockNo: '2412', date: '2025-09-01' }
            ];

            for (const { stockNo, date } of testCases) {
                try {
                    log(`ğŸ“ æ¸¬è©¦å¯«å…¥: ${stockNo} ${date}`, 'log');
                    await idbSetPermanentInvalid(stockNo, date);
                    log(`âœ… å®Œæˆ: ${stockNo} ${date}`, 'success');
                } catch (error) {
                    log(`âŒ å¤±æ•—: ${stockNo} ${date} - ${error}`, 'error');
                }
            }

            log('â”â”â” æ¸¬è©¦å®Œæˆï¼Œæª¢æŸ¥è³‡æ–™åº«å…§å®¹ â”â”â”', 'log');
            await checkDatabase();
        }

        async function checkDatabase() {
            log('â”â”â” æª¢æŸ¥è³‡æ–™åº«å…§å®¹ â”â”â”', 'log');
            try {
                const db = await initIDB();
                if (!db) {
                    log('âŒ ç„¡æ³•é–‹å•Ÿè³‡æ–™åº«', 'error');
                    return;
                }

                const tx = db.transaction([PERMANENT_INVALID_STORE_NAME], 'readonly');
                const store = tx.objectStore(PERMANENT_INVALID_STORE_NAME);
                const getAllRequest = store.getAll();

                getAllRequest.onsuccess = () => {
                    const records = getAllRequest.result;
                    log(`âœ… è³‡æ–™åº«ä¸­å…±æœ‰ ${records.length} ç­†è¨˜éŒ„`, 'success');

                    if (records.length > 0) {
                        const pre = document.createElement('pre');
                        pre.textContent = JSON.stringify(records, null, 2);
                        document.getElementById('output').appendChild(pre);
                    }
                };

                getAllRequest.onerror = () => {
                    log('âŒ è®€å–è³‡æ–™å¤±æ•—', 'error');
                };
            } catch (error) {
                log(`âŒ æª¢æŸ¥è³‡æ–™åº«å¤±æ•—: ${error}`, 'error');
            }
        }

        async function clearDB() {
            log('â”â”â” æ¸…é™¤è³‡æ–™åº« â”â”â”', 'log');
            idbInstance = null;
            const deleteRequest = indexedDB.deleteDatabase(IDB_CONFIG.name);
            deleteRequest.onsuccess = () => {
                log('âœ… è³‡æ–™åº«å·²æ¸…é™¤', 'success');
            };
            deleteRequest.onerror = () => {
                log('âŒ æ¸…é™¤è³‡æ–™åº«å¤±æ•—', 'error');
            };
        }

        // åˆå§‹åŒ–æç¤º
        log('ğŸš€ æ¸¬è©¦å·¥å…·å·²å°±ç·’', 'log');
        log('ğŸ’¡ æœ¬æ¸¬è©¦ä½¿ç”¨ worker.js çš„å¯¦éš›ä»£ç¢¼è·¯å¾‘', 'log');
        log('âš ï¸ è«‹å…ˆæ¸…é™¤è³‡æ–™åº«ï¼Œå†åŸ·è¡Œæ¸¬è©¦', 'warn');
    </script>
</body>

</html>