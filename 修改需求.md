**行為準則:** 



\* 記得以下所有的變動, 不能使原始程式碼的核心功能造成簡化, 省略, 或過度刪除. 僅保留增減本次預計變動的功能. 程式碼更新後,不能在原本的程式碼中出現"因....省略"或"與...相同"的備註, 然後下面程式碼消失.

\* 若給你的程式碼中出現"因....省略"或"與...相同"的備註, 請於修改後務必檢查後面原本的程式碼內容是否完整寫入, 不能直接讓備註後面的原始程式碼消失.

\* 檔案修改完成後, 比對原本檔案的程式碼總行數與修改後的程式碼總行數. 如果出現兩個程式碼總行數相差過大的狀況, (例如達到20%以上的總行數差距), 請通知使用者





**修改行動:** 


工作指令：優化回測資料獲取效能

指派對象： AI 工程師

由： Lazybacktest 網頁工程師

主題： Refactor 前端 Worker 資料獲取邏輯以最小化網路請求與延遲

背景：
經分析 log.txt，已確認目前系統在處理上櫃 (TPEX) 股票回測時，前端 worker.js 會發送大量重複的 API 請求，導致不必要的等待時間。此問題根源在於 fetchStockData 函式採用了逐月請求的舊有模式，未能匹配後端代理服務 (tpex-proxy.js) 已升級為一次性返回完整歷史數據的優化架構。此現象與先前已修復的上市 (TWSE) 股票問題相同。

任務目標：
為徹底解決此效能瓶頸，需重構 js/worker.js 中的 fetchStockData 函式。目標是將上市 (TWSE) 與上櫃 (TPEX) 的資料獲取流程統一，無論市場類型，前端 Worker 都僅發送一次請求至對應的 Netlify Function Proxy，並在前端完成後續的日期篩選與資料格式化。

具體需求與規格：

統一請求邏輯：

移除 js/worker.js 內 fetchStockData 函式中所有針對上市或上櫃股票的迴圈（while 或 for）逐月請求邏輯。

函式應根據傳入的 marketType 參數，動態決定是呼叫 /twse-proxy 還是 /tpex-proxy。

請求的 URL 中不應再包含日期參數，僅需傳遞 stockNo。

前端職責劃分：

後端 Proxy 的職責是獲取並快取該股票所有的歷史資料。

前端 Worker 的職責是接收完整的資料後，根據使用者選定的 startDate 與 endDate 在記憶體中進行篩選、格式化及排序。

錯誤與資訊處理：

函式需能妥善處理代理伺服器回傳的錯誤（如 404, 500）以及業務邏輯錯誤（如 data.error）。

新增資訊回傳機制：在成功獲取資料後，透過 postMessage 將 stockNameInfo（包含股票名稱、代號、市場類型）傳遞給主線程，以便 UI 即時更新。

若代理伺服器回傳查無資料的特定錯誤，應透過 marketError 訊息通知主線程，以觸發市場自動切換的 UI/UX 流程。

實作程式碼：

請使用以下程式碼完整覆蓋 js/worker.js 檔案中的 fetchStockData 函式，以確保其符合上述所有規格。

JavaScript

// AITask: Replace the existing fetchStockData function in js/worker.js with the following code block.
async function fetchStockData(stockNo, startDate, endDate, marketType) {
    if (!marketType) {
        throw new Error('fetchStockData 缺少 marketType 參數! 無法判斷上市或上櫃。');
    }
    self.postMessage({ type: 'progress', progress: 5, message: `準備從 ${marketType.toUpperCase()} 獲取數據...` });

    // 根據市場類型決定代理路徑
    const proxyPath = marketType === 'tpex' ? 'tpex-proxy' : 'twse-proxy';
    const proxyUrl = `/.netlify/functions/${proxyPath}?stockNo=${stockNo}`;

    try {
        const response = await fetch(proxyUrl);
        if (!response.ok) {
            const errorBody = await response.text();
            throw new Error(`代理伺服器錯誤: ${response.status} - ${errorBody}`);
        }
        
        const data = await response.json();
        if (data.error) throw new Error(`代理回傳錯誤: ${data.error}`);
        
        self.postMessage({ type: 'progress', progress: 25, message: '數據獲取成功，處理中...' });

        if (!data.aaData || data.aaData.length === 0) {
            console.warn(`[Worker] 從代理 ${marketType.toUpperCase()} 未收到任何原始數據`);
            // 向主線程發送股票名稱資訊
            self.postMessage({ type: 'stockNameInfo', stockName: data.stockName || stockNo, stockNo: stockNo, marketType: marketType });
            return { data: [], dataSource: data.dataSource, stockName: data.stockName };
        }
        
        // 向主線程發送股票名稱資訊
        self.postMessage({ type: 'stockNameInfo', stockName: data.stockName || stockNo, stockNo: stockNo, marketType: marketType });
        
        // 將從 proxy 獲得的完整資料進行日期篩選與格式化
        const formattedData = data.aaData.map(item => {
            const dateStr = formatTWDateWorker(item[0]);
            if (!dateStr) return null;

            const itemDate = new Date(dateStr);
            if (isNaN(itemDate.getTime())) return null;

            // 篩選日期
            if (itemDate >= new Date(startDate) && itemDate <= new Date(endDate)) {
                const o = parseFloat(String(item[3]).replace(/,/g, ''));
                const h = parseFloat(String(item[4]).replace(/,/g, ''));
                const l = parseFloat(String(item[5]).replace(/,/g, ''));
                const c = parseFloat(String(item[6]).replace(/,/g, ''));
                const v = parseInt(String(item[8]).replace(/,/g, ''), 10);
                
                if ([o, h, l, c, v].some(isNaN)) return null;
                
                return { date: dateStr, open: o, high: h, low: l, close: c, volume: v / 1000 };
            }
            return null;
        }).filter(item => item !== null);

        // 按日期排序確保順序正確
        const sortedData = formattedData.sort((a, b) => new Date(a.date) - new Date(b.date));
        
        self.postMessage({ type: 'progress', progress: 50, message: '數據處理完成...' });
        
        if (sortedData.length === 0) {
            throw new Error(`指定範圍 (${startDate} ~ ${endDate}) 無 ${stockNo} 交易數據`);
        }

        return { data: sortedData, dataSource: data.dataSource, stockName: data.stockName };

    } catch (error) {
        console.error(`[Worker] 獲取或處理 ${stockNo} (${marketType}) 資料時發生錯誤:`, error);
        // 如果是查無資料的特定錯誤，發送 marketError
        if (error.message.includes("not found")) {
             self.postMessage({ type: 'marketError', message: `在 ${marketType.toUpperCase()} 市場中找不到股票代號 ${stockNo}。`, stockNo: stockNo, marketType: marketType });
        }
        throw error;
    }
}
驗收標準：

在開發者工具的網路(Network)分頁中，針對任何一支上市或上櫃股票執行回測，tpex-proxy 或 twse-proxy 的請求都應只出現一次。

回測結果應與修改前保持一致。

使用者感知的等待時間應有顯著改善。

請在完成後通知我進行 Code Review。如有任何疑問，請隨時提出。}