**行為準則:** 



\* 記得以下所有的變動, 不能使原始程式碼的核心功能造成簡化, 省略, 或過度刪除. 僅保留增減本次預計變動的功能. 程式碼更新後,不能在原本的程式碼中出現"因....省略"或"與...相同"的備註, 然後下面程式碼消失.

\* 若給你的程式碼中出現"因....省略"或"與...相同"的備註, 請於修改後務必檢查後面原本的程式碼內容是否完整寫入, 不能直接讓備註後面的原始程式碼消失.

\* 檔案修改完成後, 比對原本檔案的程式碼總行數與修改後的程式碼總行數. 如果出現兩個程式碼總行數相差過大的狀況, (例如達到20%以上的總行數差距), 請通知使用者





**修改行動:** 


工作指令：重構 worker.js 資料獲取邏輯
任務 ID: TASK-WORKER-OPT-V10.2

指派對象: AI 工程師

由: Lazybacktest 網頁工程師

日期: 2025年9月19日

優先級: 高 (High) - 此問題阻擋了核心回測功能的正常運作。

1. 摘要 (Background Summary)
上櫃 (TPEX) 股票的回測功能目前已確認失敗。根據提供的 log.md 檔案分析，前端 worker.js 在獲取資料時，從後端代理服務收到了 400 - {"error":"缺少參數"} 的錯誤回應，導致回測中止。

雖然 log.md 顯示 tpex-proxy 函式本身有被觸發，但 worker.js 內部的資料請求方式存在根本性問題，導致了此次失敗。

2. 問題根源分析 (Root Cause Analysis)
經過對 worker.js 檔案的程式碼審查，確認問題根源如下：

過時的請求邏輯： 目前 worker.js 中的 fetchStockData 函式仍然採用了舊版的逐月請求模式。它透過一個 while 迴圈來遍歷使用者選擇的日期區間，並在迴圈中為每個月都發送一次獨立的 fetch 請求。

錯誤的參數傳遞： 在上述的迴圈中，程式碼會建構一個包含 date 參數的 URL (例如 ...&date=20240901) 並發送到後端。

前後端規格不匹配： 我們先前已將後端代理服務 (tpex-proxy.js 與 twse-proxy.js) 優化為一次性獲取完整歷史資料，因此它們不再需要，也不接受 date 參數。当前端 worker.js 發送了這個多餘的參數時，就觸發了後端的回應錯誤，儘管錯誤訊息本身可能不夠精確，但根本原因就是此一參數不匹配。

總結來說，worker.js 的實作與後端的 API 規格不一致，是導致此錯誤的直接原因。

3. 任務目標 (Task Objective)
重構 js/worker.js 檔案中的 fetchStockData 函式。必須移除現有的逐月迴圈請求邏輯，並將其替換為一個統一的、一次性的資料請求函式，使其能夠正確地與優化後的後端代理服務溝通。

4. 實作規格 (Implementation Details)
檔案： js/worker.js
函式： fetchStockData

請使用以下程式碼完整覆蓋現有的 fetchStockData 函式。此版本已實現了統一的請求邏輯。

版本代碼: worker-v10.2-final

JavaScript

// AITask: 請使用此程式碼塊，完整替換 worker.js 檔案中的 fetchStockData 函式。
async function fetchStockData(stockNo, startDate, endDate, marketType) {
    if (!marketType) {
        throw new Error('fetchStockData 缺少 marketType 參數! 無法判斷上市或上櫃。');
    }
    self.postMessage({ type: 'progress', progress: 5, message: `準備從 ${marketType.toUpperCase()} 獲取數據...` });

    // 根據市場類型動態決定代理路徑，並只傳遞 stockNo
    const proxyPath = marketType === 'tpex' ? 'tpex-proxy' : 'twse-proxy';
    const proxyUrl = `/.netlify/functions/${proxyPath}?stockNo=${stockNo}`;

    try {
        // 發送一次性的網路請求
        const response = await fetch(proxyUrl);
        if (!response.ok) {
            const errorBody = await response.text();
            throw new Error(`代理伺服器錯誤: ${response.status} - ${errorBody}`);
        }
        
        const data = await response.json();
        if (data.error) throw new Error(`代理回傳錯誤: ${data.error}`);
        
        self.postMessage({ type: 'progress', progress: 25, message: '數據獲取成功，處理中...' });

        if (!data.aaData || data.aaData.length === 0) {
            console.warn(`[Worker] 從代理 ${marketType.toUpperCase()} 未收到任何原始數據`);
            self.postMessage({ type: 'stockNameInfo', stockName: data.stockName || stockNo, stockNo: stockNo, marketType: marketType });
            return { data: [], dataSource: data.dataSource, stockName: data.stockName };
        }
        
        self.postMessage({ type: 'stockNameInfo', stockName: data.stockName || stockNo, stockNo: stockNo, marketType: marketType });
        
        // 將完整的歷史資料在前端進行日期篩選
        const formattedData = data.aaData.map(item => {
            const dateStr = formatTWDateWorker(item[0]);
            if (!dateStr) return null;

            const itemDate = new Date(dateStr);
            if (isNaN(itemDate.getTime())) return null;

            if (itemDate >= new Date(startDate) && itemDate <= new Date(endDate)) {
                const o = parseFloat(String(item[3]).replace(/,/g, ''));
                const h = parseFloat(String(item[4]).replace(/,/g, ''));
                const l = parseFloat(String(item[5]).replace(/,/g, ''));
                const c = parseFloat(String(item[6]).replace(/,/g, ''));
                const v = parseInt(String(item[8]).replace(/,/g, ''), 10);
                
                if ([o, h, l, c, v].some(isNaN)) return null;
                
                return { date: dateStr, open: o, high: h, low: l, close: c, volume: v / 1000 };
            }
            return null;
        }).filter(item => item !== null);

        const sortedData = formattedData.sort((a, b) => new Date(a.date) - new Date(b.date));
        
        self.postMessage({ type: 'progress', progress: 50, message: '數據處理完成...' });
        
        if (sortedData.length === 0) {
            throw new Error(`指定範圍 (${startDate} ~ ${endDate}) 無 ${stockNo} 交易數據`);
        }

        return { data: sortedData, dataSource: data.dataSource, stockName: data.stockName };

    } catch (error) {
        console.error(`[Worker] 獲取或處理 ${stockNo} (${marketType}) 資料時發生錯誤:`, error);
        if (error.message.includes("not found")) {
             self.postMessage({ type: 'marketError', message: `在 ${marketType.toUpperCase()} 市場中找不到股票代號 ${stockNo}。`, stockNo: stockNo, marketType: marketType });
        }
        throw error;
    }
}
5. 驗收標準 (Acceptance Criteria)
AC1: 執行任何上市 (TWSE) 或上櫃 (TPEX) 股票的回測時，瀏覽器開發者工具的「網路 (Network)」分頁中，針對 tpex-proxy 或 twse-proxy 的請求只會出現一次。

AC2: 針對上櫃股票的回測必須能夠成功完成，不再出現 400 錯誤。

AC3: 資料獲取的等待時間應顯著縮短，使用者體驗更加流暢。