# 🚀 Vibe Coding 快速提示詞集合

> **使用方法**: 找到符合您的場景的提示詞，複製整段文字，粘貼給 AI 助手即可。AI 會自動遵循架構生成代碼。

---

## 📑 目錄

1. [API 層提示詞](#api-層提示詞)
2. [Core 層提示詞](#core-層提示詞)
3. [UI 層提示詞](#ui-層提示詞)
4. [Utils 層提示詞](#utils-層提示詞)
5. [整合和重構提示詞](#整合和重構提示詞)
6. [故障排查提示詞](#故障排查提示詞)

---

## 🔌 API 層提示詞

### 提示詞 #1: 添加新 API 端點

```
我要在 LazyBacktest 項目中添加新的 API 端點。

【添加要求】
端點名稱: [填寫名稱，例如: getStockDividends]
API 路徑: [填寫路徑，例如: /api/stock/{ticker}/dividends]
請求方法: [GET/POST/PUT/DELETE]
參數: [列出所有參數，例如: ticker (string), startDate (date), endDate (date)]
返回格式: [描述返回數據結構]

【架構要求】
1. 在 js/layers/api/proxy-client.js 添加方法
2. 必須包含:
   - 輸入參數驗證
   - 錯誤處理
   - 重試機制 (使用 withRetry)
   - 超時設置
   - 清晰的註釋

3. 在 tests/unit/api/proxy-client.test.js 編寫測試:
   - 正常情況測試
   - 異常情況測試（404、500 等）
   - 超時測試
   - 重試機制測試
   - 參數驗證測試

【代碼風格】
- 遵循現有的 getStockData 方法風格
- 使用 async/await
- 使用 try-catch 進行錯誤處理
- 添加詳細的 JSDoc 註釋

【質量要求】
- 代碼覆蓋率 > 90%
- 所有測試必須通過
- 沒有 console.log

準備好後，我會使用 npm test 驗證所有測試通過。
```

**複製提示詞並填寫 [] 內的內容**

---

### 提示詞 #2: 修改現有 API 端點

```
我要修改 LazyBacktest 中現有的 API 端點 [端點名稱]。

【修改需求】
當前功能: [描述當前功能]
需要修改: [描述需要改變的地方]
新增功能: [如果有的話]

【架構要求】
1. 修改 js/layers/api/proxy-client.js 中的方法
2. 確保向後兼容性
3. 如果改變了返回格式，更新所有使用該方法的地方

4. 更新或新增測試在 tests/unit/api/proxy-client.test.js
   - 測試新功能
   - 確保舊功能仍然工作
   - 添加回歸測試

【質量檢查】
- 運行 npm test 確保所有現有測試通過
- 新測試覆蓋率 > 85%
- 沒有破壞現有代碼

準備好後我會驗證修改不會破壞其他功能。
```

---

### 提示詞 #3: 添加 API 緩存機制

```
我要為 LazyBacktest 的 API 層添加緩存機制。

【緩存要求】
緩存哪個端點: [例如: getStockData]
緩存時長: [例如: 5 分鐘]
緩存鍵生成規則: [例如: ticker + startDate + endDate]
當緩存過期時: [重新取數據/返回 null]

【架構要求】
1. 在 js/layers/api/proxy-client.js 添加緩存邏輯
2. 使用現有的緩存機制或創建新的
3. 必須包含:
   - 緩存命中檢查
   - 超期處理
   - 緩存清除功能
   - 詳細註釋

4. 在 tests/unit/api/proxy-client.test.js 編寫測試:
   - 緩存命中測試
   - 緩存過期測試
   - 緩存清除測試
   - 性能對比測試

【質量要求】
- 緩存命中率測試
- 確保不影響其他功能
- 性能提升至少 50%

驗證緩存工作正常和性能改善。
```

---

## 💼 Core 層提示詞

### 提示詞 #4: 添加新的性能指標

```
我要在 LazyBacktest 的 BacktestEngine 中添加新的性能指標。

【指標要求】
指標名稱: [例如: CalmarRatio]
計算公式: [詳細寫出計算步驟]
輸入參數: [例如: trades (Array), riskFreeRate (Number)]
輸出格式: [例如: Number, 精確到小數點後 2 位]
業務含義: [解釋這個指標的含義]

【架構要求】
1. 在 js/layers/core/backtest-engine.js 添加新方法
2. 方法名: calculate[指標名稱]
3. 必須包含:
   - 輸入驗證（檢查參數類型和有效性）
   - 邊界情況處理
   - 詳細的計算過程註釋
   - 結果四捨五入到合理的精度

4. 在 tests/unit/core/backtest-engine.test.js 編寫測試:
   - 正常情況測試（包含已知的計算結果）
   - 邊界情況測試（空數組、單個元素、負數等）
   - 精度測試（確保四捨五入正確）
   - 性能測試（支持 10,000+ 筆交易）

【代碼示例參考】
查看現有的 calculateSharpeRatio 或 calculateMaxDrawdown 方法的實現方式

【質量要求】
- 計算結果可驗證（包含已知的測試案例）
- 測試覆蓋率 > 95%
- 性能在 100ms 內（針對 10,000 筆交易）
- 清晰的變數名和註釋

準備好後，我會用已知案例驗證計算的正確性。
```

---

### 提示詞 #5: 添加新的技術指標

```
我要在 LazyBacktest 的 Indicators 中添加新的技術指標。

【指標要求】
指標名稱: [例如: KeltnerChannel]
計算公式: [詳細的數學公式]
參數:
  - 必需參數: [例如: data (Array), period (Number)]
  - 可選參數: [例如: offset (Number, 預設 2)]
輸出格式: [例如: { upper: Number, middle: Number, lower: Number }]

【架構要求】
1. 在 js/layers/core/indicators.js 添加新方法
2. 方法特點:
   - 使用純函數（無狀態）
   - 不能有副作用
   - 支持大數據集（10,000+ 數據點）
   - 性能要求: 1,000 個數據點在 100ms 內完成

3. 必須包含:
   - 輸入驗證（數據類型、長度等）
   - 有意義的錯誤信息
   - 性能優化（向量化計算而非循環）
   - 詳細的公式解釋註釋

4. 在 tests/unit/core/indicators.test.js 編寫測試:
   - 已知數據的計算測試（使用可驗證的結果）
   - 邊界情況測試（空數組、不足 period 個數據等）
   - 大數據集性能測試
   - 精度測試（浮點數四捨五入）

【參考實現】
查看現有的 calculateSMA 或 calculateRSI 方法的實現方式

【質量要求】
- 計算結果精確（相比標準實現誤差 < 0.01%）
- 測試覆蓋率 > 95%
- 大數據集性能測試通過
- 清晰的代碼和詳細註釋

驗證計算準確性和性能指標。
```

---

### 提示詞 #6: 添加新的策略管理功能

```
我要在 LazyBacktest 的 StrategyManager 中添加新的功能。

【功能要求】
功能名稱: [例如: Strategy Versioning]
功能描述: [詳細描述要添加什麼功能]
使用場景: [解釋何時使用這個功能]

【架構要求】
1. 在 js/layers/core/strategy-manager.js 添加新方法
2. 必須包含:
   - 新方法的清晰定義
   - 與現有方法的協調
   - 數據驗證和錯誤處理
   - 詳細的 JSDoc 註釋

3. 不能跨越層的邊界（不做 API 調用或 UI 操作）

4. 在 tests/unit/core/strategy-manager.test.js 編寫測試:
   - 基本功能測試
   - 邊界情況測試
   - 與現有功能的兼容性測試
   - 錯誤處理測試

【質量要求】
- 測試覆蓋率 > 90%
- 向後兼容（不破壞現有 API）
- 清晰的文檔註釋

驗證新功能與現有功能協調無誤。
```

---

## 🎨 UI 層提示詞

### 提示詞 #7: 添加新的表單字段

```
我要在 LazyBacktest 的 UIController 中添加新的表單字段。

【字段要求】
字段名稱: [例如: strategyType]
字段類型: [text / number / select / checkbox 等]
標籤: [用戶看到的標籤文本]
驗證規則: [例如: 必填、長度限制、格式要求等]
默認值: [如果有的話]

【架構要求】
1. 在 js/layers/ui/ui-controller.js 中添加:
   - getFieldValue() 方法（從 DOM 取值）
   - validateField() 方法（驗證值）
   - displayError() 方法（顯示錯誤）

2. 不能在 UI 層做業務計算
   - 計算邏輯應在 Core 層
   - UI 層只負責收集和驗證

3. 使用 StateManager 保存狀態:
   - this.stateManager.saveState(fieldName, value)

4. 在 tests/unit/ui/ui-controller.test.js 編寫測試:
   - DOM 元素存在檢查
   - 值提取測試
   - 驗證規則測試
   - 錯誤顯示測試
   - 狀態保存測試

【代碼示例參考】
查看現有的表單字段實現（如 ticker 字段）

【質量要求】
- 測試覆蓋率 > 90%
- 驗證邏輯完善
- 錯誤信息清晰
- 用戶體驗流暢

驗證表單功能完整和用戶體驗良好。
```

---

### 提示詞 #8: 修改現有的顯示邏輯

```
我要修改 LazyBacktest 的 UIController 中的顯示邏輯。

【修改要求】
當前顯示: [描述當前如何顯示的]
需要修改: [描述想要的新方式]
數據來源: [數據從哪裡來]

【架構要求】
1. 修改 js/layers/ui/ui-controller.js 中的相應方法
2. 確保:
   - 數據不被修改（只做展示）
   - 清晰的代碼註釋
   - 保持風格一致

3. 更新相關測試在 tests/unit/ui/ui-controller.test.js:
   - 顯示格式測試
   - 數據轉換測試
   - 邊界情況測試
   - 用戶交互測試

【質量要求】
- 測試覆蓋率 > 90%
- 不破壞現有功能
- 用戶體驗改善

驗證顯示邏輯正確和用戶體驗改善。
```

---

## 🛠️ Utils 層提示詞

### 提示詞 #9: 添加新的工具函數

```
我要在 LazyBacktest 的 Utils 層添加新的工具函數。

【工具要求】
工具名稱: [例如: formatPortfolioValue]
用途: [這個函數做什麼]
輸入參數: [例如: value (Number), locale (String)]
返回值: [例如: String 格式化後的值]
使用場景: [在哪些地方會用到]

【架構要求】
1. 確定應該放在哪個文件:
   - js/layers/utils/date-utils.js (日期相關)
   - js/layers/utils/math-utils.js (數學計算)
   - js/layers/utils/format-utils.js (格式化)
   - 或新建相應的文件

2. 函數必須是:
   - 純函數（無副作用）
   - 無狀態（相同輸入總是相同輸出）
   - 高度可復用（可被多個層使用）
   - 清晰的參數和返回值類型

3. 添加詳細的 JSDoc 註釋:
   - 函數說明
   - 參數說明
   - 返回值說明
   - 使用示例

4. 在 tests/unit/utils/[文件名].test.js 編寫測試:
   - 正常情況測試
   - 邊界情況測試
   - 異常輸入測試
   - 性能測試（如適用）

【質量要求】
- 測試覆蓋率 > 95%
- 代碼簡潔易懂
- 詳細的註釋和文檔

驗證工具函數正確和可復用性。
```

---

## 🔗 整合和重構提示詞

### 提示詞 #10: 創建新的完整功能流程

```
我要在 LazyBacktest 中創建一個新的完整功能。

【功能要求】
功能名稱: [例如: Portfolio Risk Analysis]
功能描述: [詳細描述這個功能]

完整流程:
  1. 用戶輸入: [用戶提供什麼]
  2. 數據獲取: [從哪裡獲取數據]
  3. 計算處理: [如何處理和計算]
  4. 結果展示: [如何展示結果]

【架構要求】
按層級實現:

1️⃣ API 層 (js/layers/api/proxy-client.js)
   - 添加方法來獲取必要的外部數據
   - 包含錯誤處理和重試機制

2️⃣ Core 層 (js/layers/core/)
   - 在 backtest-engine.js 或新文件中添加計算邏輯
   - 在 indicators.js 中添加需要的指標計算
   - 在 strategy-manager.js 中集成策略管理

3️⃣ Utils 層 (js/layers/utils/)
   - 添加必要的工具函數
   - 數據轉換和格式化

4️⃣ UI 層 (js/layers/ui/)
   - 在 ui-controller.js 添加表單收集和顯示邏輯
   - 在 state-manager.js 中定義狀態結構

【測試要求】
1. 單元測試 (tests/unit/)
   - API 層: 數據獲取測試
   - Core 層: 計算邏輯測試
   - UI 層: 交互和顯示測試
   - Utils: 工具函數測試

2. 整合測試 (tests/integration/)
   - 端到端流程測試
   - 層與層之間的協作測試

【質量檢查】
- 整個功能的測試覆蓋率 > 85%
- 所有測試必須通過
- 沒有代碼重複
- 清晰的文檔和註釋

準備好後，我會運行完整的測試套件驗證功能。
```

---

### 提示詞 #11: 優化現有的功能

```
我要優化 LazyBacktest 中的 [功能名稱]。

【優化需求】
當前問題: [描述當前的問題，如性能、可維護性等]
優化目標: [具體的優化目標，如性能提升 50%]
約束條件: [如果有的話，如不能改變公共 API]

【優化範圍】
影響的層: [API / Core / UI / Utils]
涉及的文件: [列出可能需要修改的文件]

【架構要求】
1. 分析是否需要改變架構
2. 如需改變，確保改變合理且符合設計原則
3. 保持向後兼容
4. 更新所有相關測試

【測試要求】
1. 所有現有測試必須通過
2. 添加性能基準測試
3. 比較優化前後的性能差異
4. 確保沒有功能退化

【質量檢查】
- 測試覆蓋率不降低
- 性能指標達到目標
- 代碼可讀性保持或改善

準備好後，我會驗證優化效果和性能提升。
```

---

## 🔍 故障排查提示詞

### 提示詞 #12: 修復失敗的測試

```
我遇到了測試失敗的問題。

【問題信息】
失敗的測試: [複製測試的完整名稱]
錯誤信息: [複製完整的錯誤信息]
失敗文件: [測試文件位置]

【環境信息】
最近改動: [最近修改了哪些代碼]
執行命令: [運行的命令，如 npm test]
環境: [Node 版本，如果知道的話]

【期望行為】
應該: [測試應該通過]
實際: [實際發生了什麼]

【架構檢查】
請檢查:
1. 修改是否在正確的層中
2. 是否遵循了現有的代碼模式
3. 是否有任何跨層的邏輯混合
4. 是否正確導入和使用依賴

【要求】
1. 根據錯誤信息診斷問題
2. 提供最小化的修複
3. 確保不破壞其他測試
4. 添加註釋說明修複原因

準備好後，我會運行所有測試驗證修複有效。
```

---

### 提示詞 #13: 修復代碼 Bug

```
我發現了一個 Bug。

【Bug 描述】
功能: [受影響的功能]
現象: [實際表現出來的問題]
期望行為: [應該怎樣]

【復現步驟】
1. [第一步]
2. [第二步]
3. [第三步]
...

【影響範圍】
受影響的文件: [可能受影響的文件]
影響的功能: [可能影響其他什麼]

【分析】
我認為問題在: [如果你有猜測的話]

【架構要求】
1. 定位 Bug 的確切原因
2. 確認 Bug 在正確的層中
3. 最小化修改

【修複要求】
1. 修複代碼
2. 添加回歸測試防止再次發生
3. 確保不破壞現有功能

準備好後，我會:
1. 驗證 Bug 確實被修複
2. 運行所有相關測試
3. 確保沒有新的問題引入
```

---

### 提示詞 #14: 處理代碼衝突

```
我需要整合來自不同分支的改動。

【衝突信息】
衝突文件: [列出有衝突的文件]
分支 A: [第一個分支名]
分支 B: [第二個分支名]

【改動摘要】
分支 A 的改動: [簡述]
分支 B 的改動: [簡述]
兩者的關係: [是否相關]

【架構檢查】
1. 兩個改動是否都符合架構規則
2. 是否可以共存
3. 是否需要重構來統一風格

【集成要求】
1. 解決衝突
2. 確保兩個功能都正常工作
3. 所有相關測試必須通過
4. 代碼風格統一

準備好後，我會:
1. 驗證衝突已解決
2. 運行所有測試確保功能正常
3. 檢查代碼質量
```

---

## 💡 如何最大效率使用這些提示詞

### 快速複製流程

```
1️⃣ 找到符合您場景的提示詞
2️⃣ 完整複製整個提示詞 (包括標記符號)
3️⃣ 粘貼到 AI 聊天框
4️⃣ 根據 [] 標記填寫具體信息
5️⃣ 發送給 AI
6️⃣ AI 會按照提示詞生成代碼
7️⃣ 驗證代碼符合要求
8️⃣ 運行 npm test 驗證
```

### 提示詞定制技巧

```
✅ 可以修改的部分:
- [] 內的填空內容
- 示例代碼
- 測試場景

❌ 不要修改的部分:
- 【架構要求】部分（這是硬性要求）
- 【質量要求】部分（這確保代碼質量）
- 層級相關的說明
```

### 組合多個提示詞

```
場景: 添加新功能並優化性能

步驟:
1️⃣ 使用提示詞 #10 (創建新功能)
   生成完整的新功能代碼

2️⃣ 運行測試確保功能正常
   npm test

3️⃣ 使用提示詞 #11 (優化功能)
   在新功能基礎上進行優化

4️⃣ 再次運行測試
   npm test && npm run test:coverage

5️⃣ 提交代碼
```

---

## 📞 快速參考表

### 按層級選擇提示詞

| 層 | 提示詞 | 常見場景 |
|---|-------|---------|
| **API** | #1, #2, #3 | 新端點、修改端點、添加緩存 |
| **Core** | #4, #5, #6 | 新指標、新計算、策略管理 |
| **UI** | #7, #8 | 新表單、修改顯示 |
| **Utils** | #9 | 工具函數 |
| **整合** | #10, #11 | 新功能、優化 |
| **故障排查** | #12, #13, #14 | 測試失敗、Bug、衝突 |

### 按任務選擇提示詞

| 任務 | 推薦提示詞 | 備註 |
|------|----------|------|
| 快速添加功能 | #1, #4, #7 | 單層修改 |
| 完整新功能 | #10 | 多層協作 |
| 性能優化 | #11 | 保持功能不變 |
| Bug 修復 | #12, #13 | 快速修復 |
| 重構代碼 | #11 + #10 | 改進設計 |

---

## 🎯 最佳實踐

### DO ✅
- ✅ 使用完整的提示詞（不要刪除部分）
- ✅ 詳細填寫 [] 內的信息
- ✅ 遵循提示詞中的要求
- ✅ 執行建議的測試命令
- ✅ 驗證代碼質量

### DON'T ❌
- ❌ 不要修改【架構要求】部分
- ❌ 不要跳過測試步驟
- ❌ 不要忽視代碼覆蓋率要求
- ❌ 不要混合多個提示詞
- ❌ 不要提交未測試的代碼

---

## 🆘 如果提示詞不工作

### 問題 1: AI 生成了不符合架構的代碼

**解決方案**:
```
重新提示詞，在開頭加上:

"特別注意: 這是 LazyBacktest 項目的嚴格架構，必須遵守:
- API 層只做網絡請求
- Core 層只做業務邏輯
- UI 層只做用戶交互
- Utils 層只提供工具函數

不能跨層混合邏輯。"

然後再貼提示詞。
```

### 問題 2: AI 缺少了必要的測試

**解決方案**:
```
補充提示:

"代碼完成後，請編寫對應的測試:
- 單元測試在 tests/unit/ 中
- 測試要覆蓋: 正常情況、異常情況、邊界情況
- 測試覆蓋率要求: > 85%"
```

### 問題 3: AI 生成的代碼風格不一致

**解決方案**:
```
在提示詞開頭加上:

"請參考現有代碼的風格（以 [文件名] 為例）
遵循:
- 命名規範: camelCase
- 註釋風格: JSDoc
- 縮排: 2 個空格
- 錯誤處理: try-catch 或 reject"
```

---

## 🎉 快速檢查清單

在使用提示詞前檢查:

- [ ] 找到了符合場景的提示詞
- [ ] 完整複製了提示詞
- [ ] 填寫了所有 [] 內的信息
- [ ] 沒有修改【架構要求】部分
- [ ] 準備好了運行測試

使用提示詞後檢查:

- [ ] AI 生成的代碼符合架構
- [ ] 包含了所有必要的測試
- [ ] 代碼風格一致
- [ ] 運行 npm test 全部通過
- [ ] 測試覆蓋率滿足要求

---

## 📚 相關資源

- [`VIBE-CODING-ASSISTANT-GUIDE.md`](VIBE-CODING-ASSISTANT-GUIDE.md) - 完整的 Vibe Coding 指南
- [`AUTOMATED-TESTING-GUIDE.md`](AUTOMATED-TESTING-GUIDE.md) - 自動測試完整指南
- [`TESTING-CHEATSHEET.md`](TESTING-CHEATSHEET.md) - 命令速查表

---

**Happy Vibe Coding! 🎵💻**

**記住**: 好的提示詞 + 架構遵守 + 自動測試 = 完美的代碼！