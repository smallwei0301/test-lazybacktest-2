# LazyBacktest 效能與日誌改善計畫

> **日期**: 2025-12-09  
> **版本**: 1.0  
> **狀態**: 待審核  

根據 `console log.md` 的診斷結果，我們發現兩個嚴重影響效能與除錯效率的問題。本計畫旨在修復重複執行與無效日誌訊息，以提升應用程式的穩定性與用戶體驗。

---

## 🛑 問題一：回測邏輯嚴重重複執行 (Critical Redundant Execution)

### 現象描述
在一次單一的回測請求中，Worker 的模擬迴圈 (`Starting simulation loop`) 被觸發了 **9 次以上**。
```text
js/worker.js:10363 [Worker] Starting simulation loop from index 104 to 1319
... (完整買賣交易日誌) ...
js/worker.js:10363 [Worker] Starting simulation loop from index 104 to 1319
... (重複出現) ...
```

### 風險評估
1.  **用戶端效能重創**：瀏覽器需處理 9 倍的運算量，導致頁面卡頓、CPU 飆升。
2.  **API 流量隱憂**：若 Worker 內部包含資料補抓邏輯 (fetch)，這將導致短時間內對 Proxy 發出大量請求，極高機率觸發 Rate Limit 或耗盡免費用戶的配額。
3.  **Race Condition**：多個回測同時在背景執行，可能導致狀態管理 (State Management) 的競爭條件，使 UI 顯示錯誤的最終結果。

### 解決方案
1.  **檢查前端觸發點**：
    *   檢視 UI 層 (如 `useEffect`) 是否有錯誤的依賴項導致組件不必要地重新渲染 (Re-render) 並觸發 Worker。
2.  **實作防抖與鎖定 (Debounce & Lock)**：
    *   在發送 Worker 訊息前加入 `isBacktesting` 狀態鎖。
    *   對按鈕點擊或參數變更加入 `debounce` 機制，避免短時間內多次觸發。

---

## ⚠️ 問題二：無效的進度條訊息轟炸 (Invalid Progress Logs)

### 現象描述
主執行緒收到大量無效的進度訊息，無法正確讀取進度值。
```text
[Main] Received message from worker: progress undefined
```

### 風險評估
1.  **主執行緒阻塞**：Worker 與 Main Thread 間的高頻通訊 ("Message Spamming") 會佔用主執行緒資源，降低 UI 響應速度。
2.  **除錯困難**：大量無效日誌掩蓋了真正重要的錯誤訊息。

### 解決方案
1.  **修正訊息結構**：
    *   **Worker 端 (`worker.js`)**：確認 `postMessage` 發送進度時的物件結構是否為 `{ type: 'progress', progress: N }` 或 `{ type: 'progress', data: N }`。
    *   **Main 端 (`backtest.js` / `app.js`)**：修正接收邏輯，確保正確解構訊息內容 (例如從 `e.data.progress` 讀取)。

---

## 🛠️ 執行步驟 (Action Plan)

### 階段一：止血 (Fix Logs)
1.  [ ] 修改 `js/worker.js`：確保進度訊息發送格式正確。
2.  [x] 修改 `js/layers/core/backtest.js`：修正進度訊息接收與解析邏輯。
    - 問題根因：`console.log` 輸出 `data` 變數，但 `progress` 訊息中沒有 `data` 屬性
    - 解決方式：過濾 `progress` 類型訊息，不再輸出到 Console
3.  [ ] 驗證：確認 `progress undefined` 消失，且 UI 進度條能正常動作。

### 階段二：根治 (Fix Redundancy)
1.  [ ] 定位調用點：找出是哪個組件 (Component) 在呼叫 `runBacktest`。
2.  [ ] 加入防護機制：
    *   若為 React 專案，檢查 `useEffect` 依賴陣列。
    *   加入 `if (isRunning) return;` 檢查。
3.  [ ] 驗證：確認點擊一次「回測」按鈕，Console 只出現一次 `Starting simulation loop`。

---

## 預期成果
*   **Console 清爽化**：不再有無效的 `undefined` 訊息。
*   **效能提升**：CPU 使用率下降，回測速度「感覺」變快 (因為只跑一次)。
*   **流量安全**：消除因重複執行導致的潛在 API 爆量風險。

---

## 🔍 風險評估

### 階段一風險（修正進度訊息）- 低風險 ✅
- **安全性**：僅修改日誌格式與解析邏輯，不影響核心回測計算。
- **回滾容易**：若出問題可快速還原。

### 階段二風險（防止重複執行）- 中等風險 ⚠️

| 風險項目 | 說明 | 緩解措施 |
|---------|------|---------|
| **誤判「正在執行」導致卡死** | 若 `isRunning` 鎖定後因錯誤未解鎖，使用者將永遠無法再執行回測 | 加入 `try-finally` 或 timeout 自動解鎖機制 |
| **敏感度分析被誤擋** | 敏感度分析本身就會執行多次回測，若一刀切禁止可能破壞功能 | 需區分「使用者觸發」與「系統批次觸發」，僅鎖定前者 |
| **React StrictMode 的雙重渲染** | 開發環境下 React 會故意渲染兩次，可能誤判為 Bug | 先確認是開發環境還是生產環境的問題 |

---

## 🔬 執行前診斷步驟（新增）

在進行階段二修改前，須先完成以下診斷以確認問題根源：

### 診斷 1：確認重複執行的參數是否相同
1. [ ] 檢查 Console 中 9 次 `Starting simulation loop` 的交易紀錄
   - **若參數相同** → 確實是 Bug（前端重複觸發）
   - **若參數不同** → 可能是敏感度分析或批次優化的**正常行為**

### 診斷 2：確認 Worker 呼叫點
1. [ ] 搜尋 `postMessage({ type: "runBacktest"` 出現次數
2. [ ] 檢查是否有迴圈包裹導致重複發送

### 診斷 3：確認敏感度分析邏輯
1. [ ] 檢查 `getSuggestion` 是否會觸發 `runStrategy` 多次
2. [ ] 根據日誌，今日建議卡片似乎也執行了完整回測，需確認這是否為預期行為

---

## 💡 額外建議

### 1. 區分「預期」與「非預期」重複
- **預期重複**：敏感度分析、批次優化、參數掃描（一次按鈕可能執行數百次回測）
- **非預期重複**：相同參數在短時間內被重複提交

### 2. 建議修改策略
若確認是非預期重複，建議採用以下防護：
```javascript
// 範例：帶有自動解鎖的狀態鎖
let isRunning = false;
let runningTimeout = null;

function runBacktest(params) {
  if (isRunning) {
    console.warn('[Main] Backtest already running, ignoring duplicate request');
    return;
  }
  
  isRunning = true;
  // 安全機制：60 秒後自動解鎖，避免永久卡死
  runningTimeout = setTimeout(() => { isRunning = false; }, 60000);
  
  try {
    worker.postMessage({ type: 'runBacktest', ...params });
  } catch (e) {
    isRunning = false;
    clearTimeout(runningTimeout);
    throw e;
  }
}

// Worker 回傳結果時解鎖
worker.onmessage = (e) => {
  if (e.data.type === 'result') {
    isRunning = false;
    clearTimeout(runningTimeout);
  }
};
```

---

## ✅ 執行建議總結

| 項目 | 評估 | 建議 |
|-----|------|------|
| 階段一 | 安全可執行 | ✅ 立即進行，清理 Console |
| 診斷步驟 | 必要 | ⚠️ 完成後再決定階段二方案 |
| 階段二 | 需更多資訊 | ⏸️ 待診斷結果確認後執行 |

**推薦執行順序**：階段一 → 重新觀察 Console → 完成診斷 → 階段二
