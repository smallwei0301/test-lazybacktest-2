<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç›´æ¥æ¸¬è©¦ IDB å‡½æ•¸</title>
    <style>
        body {
            font-family: monospace;
            padding: 20px;
            background: #1e1e1e;
            color: #d4d4d4;
        }

        .log {
            margin: 5px 0;
            padding: 8px;
            background: #252526;
            border-left: 3px solid #007acc;
            font-size: 12px;
        }

        .success {
            border-left-color: #4ec9b0;
        }

        .error {
            border-left-color: #f48771;
        }

        .warn {
            border-left-color: #dcdcaa;
        }

        button {
            padding: 10px 20px;
            margin: 5px;
            background: #007acc;
            color: white;
            border: none;
            cursor: pointer;
        }

        button:hover {
            background: #005a9e;
        }

        pre {
            background: #2d2d2d;
            padding: 10px;
            overflow-x: auto;
            max-height: 400px;
        }
    </style>
</head>

<body>
    <h1>ç›´æ¥æ¸¬è©¦ IDB å¯«å…¥å‡½æ•¸</h1>
    <p><strong>âœ… æœ¬æ¸¬è©¦ç›´æ¥è¤‡è£½ worker.js ä¸­çš„ IDB å‡½æ•¸ä¸¦åŸ·è¡Œ</strong></p>

    <button onclick="clearDB()">1. æ¸…é™¤è³‡æ–™åº«</button>
    <button onclick="testDirectWrite()">2. æ¸¬è©¦ç›´æ¥å¯«å…¥</button>
    <button onclick="checkIDB()">3. æª¢æŸ¥ IndexedDB</button>

    <div id="output"></div>

    <script>
        // ==================== ç›´æ¥å¾ worker.js è¤‡è£½çš„ä»£ç¢¼ ====================

        const IDB_CONFIG = {
            name: 'LazyBacktestDB',
            version: 4,
            storeName: 'stock_cache'
        };

        const PERMANENT_INVALID_STORE_NAME = 'permanentInvalidDates';
        const PERMANENT_INVALID_TTL_MS = 24 * 60 * 60 * 1000;
        let idbInstance = null;

        function initIDB() {
            if (idbInstance) return Promise.resolve(idbInstance);

            return new Promise((resolve) => {
                try {
                    const request = indexedDB.open(IDB_CONFIG.name, IDB_CONFIG.version);

                    request.onerror = () => {
                        console.warn('[Worker IDB] ç„¡æ³•é–‹å•Ÿ IndexedDB:', request.error);
                        resolve(null);
                    };

                    request.onsuccess = () => {
                        idbInstance = request.result;
                        console.log('[Worker IDB] IndexedDB åˆå§‹åŒ–æˆåŠŸ');
                        resolve(idbInstance);
                    };

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;

                        if (!db.objectStoreNames.contains(IDB_CONFIG.storeName)) {
                            db.createObjectStore(IDB_CONFIG.storeName);
                            console.log('[Worker IDB] å»ºç«‹ ObjectStore:', IDB_CONFIG.storeName);
                        }

                        if (!db.objectStoreNames.contains(PERMANENT_INVALID_STORE_NAME)) {
                            const permanentStore = db.createObjectStore(PERMANENT_INVALID_STORE_NAME, { keyPath: 'id' });
                            permanentStore.createIndex('stockNo', 'stockNo', { unique: false });
                            permanentStore.createIndex('expiresAt', 'expiresAt', { unique: false });
                            console.log('[Worker IDB] å»ºç«‹ ObjectStore:', PERMANENT_INVALID_STORE_NAME);
                        }
                    };
                } catch (error) {
                    console.warn('[Worker IDB] IndexedDB åˆå§‹åŒ–å¤±æ•— (å¯èƒ½ç‚ºéš±ç§æ¨¡å¼):', error);
                    resolve(null);
                }
            });
        }

        // â­ é€™æ˜¯æˆ‘å€‘è¦æ¸¬è©¦çš„æ ¸å¿ƒå‡½æ•¸ï¼ˆå¾ worker.js ç¬¬ 775 è¡Œè¤‡è£½ï¼‰
        async function idbSetPermanentInvalid(stockNo, date) {
            console.log(`[Worker IDB Debug] idbSetPermanentInvalid called for ${stockNo} ${date}`);
            try {
                const db = await initIDB();
                console.log(`[Worker IDB Debug] DB initialized: ${!!db}`);
                if (!db) {
                    console.warn('[Worker IDB] ç„¡æ³•å¯«å…¥æ°¸ä¹…ç„¡æ•ˆæ—¥æœŸï¼ŒDB æœªåˆå§‹åŒ–');
                    return;
                }

                const expiresAt = Date.now() + PERMANENT_INVALID_TTL_MS;
                const entry = {
                    id: `${stockNo}|${date}`,
                    stockNo,
                    date,
                    expiresAt,
                    recordedAt: Date.now()
                };

                return new Promise((resolve, reject) => {
                    console.log(`[Worker IDB Debug] Creating transaction for ${PERMANENT_INVALID_STORE_NAME}`);
                    try {
                        const transaction = db.transaction([PERMANENT_INVALID_STORE_NAME], 'readwrite');
                        const store = transaction.objectStore(PERMANENT_INVALID_STORE_NAME);
                        const request = store.put(entry); // âœ… ä¿®æ­£å¾Œï¼šåªå‚³ä¸€å€‹åƒæ•¸
                        console.log(`[Worker IDB Debug] Put request created`);

                        request.onsuccess = () => {
                            console.log(`[Worker IDB] å·²è¨˜éŒ„æ°¸ä¹…ç„¡æ•ˆæ—¥æœŸ: ${stockNo} - ${date}`);
                            resolve();
                        };

                        request.onerror = () => {
                            console.warn(`[Worker IDB] å¯«å…¥æ°¸ä¹…ç„¡æ•ˆæ—¥æœŸå¤±æ•—: ${stockNo} - ${date}`, request.error);
                            resolve();
                        };
                    } catch (txError) {
                        console.warn('[Worker IDB] idbSetPermanentInvalid äº¤æ˜“éŒ¯èª¤:', txError);
                        resolve();
                    }
                });
            } catch (e) {
                console.warn('[Worker IDB] idbSetPermanentInvalid éŒ¯èª¤:', e);
            }
        }

        // ==================== æ¸¬è©¦è¼”åŠ©å‡½æ•¸ ====================

        function log(message, type = 'log') {
            const output = document.getElementById('output');
            const div = document.createElement('div');
            div.className = `log ${type}`;
            const timestamp = new Date().toISOString().substr(11, 12);
            div.textContent = `[${timestamp}] ${message}`;
            output.appendChild(div);
            console.log(message);
        }

        async function clearDB() {
            log('â”â”â” æ¸…é™¤è³‡æ–™åº« â”â”â”', 'log');
            idbInstance = null;
            const deleteRequest = indexedDB.deleteDatabase(IDB_CONFIG.name);
            deleteRequest.onsuccess = () => {
                log('âœ… è³‡æ–™åº«å·²æ¸…é™¤', 'success');
            };
            deleteRequest.onerror = () => {
                log('âŒ æ¸…é™¤è³‡æ–™åº«å¤±æ•—', 'error');
            };
        }

        async function testDirectWrite() {
            log('â”â”â” é–‹å§‹ç›´æ¥å¯«å…¥æ¸¬è©¦ â”â”â”', 'log');
            log('âš ï¸ è«‹åœ¨ Console ä¸­æŸ¥çœ‹æ‰€æœ‰èª¿è©¦æ—¥èªŒï¼', 'warn');

            const testCases = [
                { stockNo: '2317', date: '2025-07-30' },
                { stockNo: '2330', date: '2025-08-15' },
                { stockNo: '2412', date: '2025-09-01' }
            ];

            for (const { stockNo, date } of testCases) {
                try {
                    log(`ğŸ“ å¯«å…¥: ${stockNo} ${date}`, 'log');
                    await idbSetPermanentInvalid(stockNo, date);
                    log(`âœ… å®Œæˆ: ${stockNo} ${date}`, 'success');
                } catch (error) {
                    log(`âŒ å¤±æ•—: ${stockNo} ${date} - ${error}`, 'error');
                }
            }

            log('â”â”â” å¯«å…¥æ¸¬è©¦å®Œæˆ â”â”â”', 'log');
            log('ğŸ’¡ è«‹é»æ“Šã€Œ3. æª¢æŸ¥ IndexedDBã€æŸ¥çœ‹çµæœ', 'warn');
        }

        async function checkIDB() {
            log('â”â”â” æª¢æŸ¥ IndexedDB å…§å®¹ â”â”â”', 'log');

            try {
                const request = indexedDB.open(IDB_CONFIG.name, IDB_CONFIG.version);

                request.onerror = () => {
                    log('âŒ ç„¡æ³•é–‹å•Ÿè³‡æ–™åº«', 'error');
                };

                request.onsuccess = () => {
                    const db = request.result;
                    log(`âœ… è³‡æ–™åº«ç‰ˆæœ¬: ${db.version}`, 'success');
                    log(`ğŸ“‚ Object Stores: ${Array.from(db.objectStoreNames).join(', ')}`, 'log');

                    if (!db.objectStoreNames.contains(PERMANENT_INVALID_STORE_NAME)) {
                        log(`âš ï¸ ${PERMANENT_INVALID_STORE_NAME} store ä¸å­˜åœ¨`, 'warn');
                        db.close();
                        return;
                    }

                    const tx = db.transaction([PERMANENT_INVALID_STORE_NAME], 'readonly');
                    const store = tx.objectStore(PERMANENT_INVALID_STORE_NAME);
                    const getAllRequest = store.getAll();

                    getAllRequest.onsuccess = () => {
                        const records = getAllRequest.result;
                        log(`âœ… ${PERMANENT_INVALID_STORE_NAME} ä¸­å…±æœ‰ ${records.length} ç­†è¨˜éŒ„`, 'success');

                        if (records.length > 0) {
                            const pre = document.createElement('pre');
                            pre.textContent = JSON.stringify(records, null, 2);
                            document.getElementById('output').appendChild(pre);

                            // æª¢æŸ¥ç›®æ¨™è¨˜éŒ„
                            const targets = [
                                '2317|2025-07-30',
                                '2330|2025-08-15',
                                '2412|2025-09-01'
                            ];

                            targets.forEach(targetId => {
                                const record = records.find(r => r.id === targetId);
                                if (record) {
                                    log(`ğŸ¯ âœ… æ‰¾åˆ°: ${targetId}`, 'success');
                                } else {
                                    log(`âš ï¸ æœªæ‰¾åˆ°: ${targetId}`, 'warn');
                                }
                            });
                        } else {
                            log('âš ï¸ æ²’æœ‰ä»»ä½•è¨˜éŒ„', 'warn');
                        }
                    };

                    getAllRequest.onerror = () => {
                        log('âŒ è®€å–è¨˜éŒ„å¤±æ•—', 'error');
                    };

                    tx.oncomplete = () => db.close();
                };
            } catch (error) {
                log(`âŒ æª¢æŸ¥å¤±æ•—: ${error.message}`, 'error');
            }
        }

        // åˆå§‹åŒ–
        log('ğŸš€ ç›´æ¥ IDB æ¸¬è©¦å·¥å…·å·²å°±ç·’', 'log');
        log('ğŸ’¡ æœ¬æ¸¬è©¦ç›´æ¥ä½¿ç”¨ worker.js çš„å¯¦éš›å‡½æ•¸ä»£ç¢¼', 'log');
        log('ğŸ“Œ è«‹æŒ‰é †åºé»æ“ŠæŒ‰éˆ•ï¼šæ¸…é™¤ â†’ æ¸¬è©¦ â†’ æª¢æŸ¥', 'warn');
        log('âš ï¸ é‡è¦ï¼šè«‹åœ¨ Console æŸ¥çœ‹å®Œæ•´çš„èª¿è©¦æ—¥èªŒ', 'warn');
    </script>
</body>

</html>